异步方案
---
### Promise
是异步编程的一种解决方案 是一个构造函数 自身有all reject resolve 原型上有 then 和 catch 方法
```js
new Promise(function (resolve, reject) {
    resolve('成功') // 数据处理完成
    // reject('失败') // 数据处理出错
  }
).then(
  (res) => {console.log(res)},  // 成功
  (err) => {console.log(err)} // 失败
)
```

三种状态

① padding 进行中
 
② fulfilled 成功

③ rejected 失败

一旦状态改变就不再改变

then对应resolve，.catch对应reject,如果.then中有两个函数，第一个是成功，第二失败

promise.all([p1,p2,p3]) 全成功，执行.then 部分失败，执行.catch

缺点

一旦新建就会立即执行 一旦执行中途无法取消

如果不设置回调 内部抛错无法反应外部

当处于pedding状态时无法得知进程情况

### Generator
是一种函数声明方式 用来解决异步问题 调用后得到一个对象
```js
function* helloGenerator() {
       yield "hello";
       yield "generator";
       return;
   }
   var h = helloGenerator();
   console.log(h.next());//{ value: 'hello', done: false }
   console.log(h.next());//{ value: 'generator', done: false }
   console.log(h.next());//{ value: 'undefined', done: true }
```

var h = helloGenerator();仅仅是创建了这个函数的句柄，并没有执行，需要next()

每执行一次next